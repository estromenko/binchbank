// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Client is an object representing the database table.
type Client struct {
	ID                     int     `boil:"id" json:"id" toml:"id" yaml:"id"`
	Age                    int     `boil:"age" json:"age" toml:"age" yaml:"age"`
	MaritialID             int     `boil:"maritial_id" json:"maritial_id" toml:"maritial_id" yaml:"maritial_id"`
	EducationID            int     `boil:"education_id" json:"education_id" toml:"education_id" yaml:"education_id"`
	GenderID               int     `boil:"gender_id" json:"gender_id" toml:"gender_id" yaml:"gender_id"`
	CardCategoryID         int     `boil:"card_category_id" json:"card_category_id" toml:"card_category_id" yaml:"card_category_id"`
	AttritionFlagID        int     `boil:"attrition_flag_id" json:"attrition_flag_id" toml:"attrition_flag_id" yaml:"attrition_flag_id"`
	MonthsOnBook           int     `boil:"months_on_book" json:"months_on_book" toml:"months_on_book" yaml:"months_on_book"`
	CreditLimit            float32 `boil:"credit_limit" json:"credit_limit" toml:"credit_limit" yaml:"credit_limit"`
	TotalRelationshipCount int     `boil:"total_relationship_count" json:"total_relationship_count" toml:"total_relationship_count" yaml:"total_relationship_count"`
	MonthInactivate12Mon   int     `boil:"month_inactivate_12_mon" json:"month_inactivate_12_mon" toml:"month_inactivate_12_mon" yaml:"month_inactivate_12_mon"`
	ContactsCount12Mon     int     `boil:"contacts_count_12_mon" json:"contacts_count_12_mon" toml:"contacts_count_12_mon" yaml:"contacts_count_12_mon"`
	TotalRemovingBal       int     `boil:"total_removing_bal" json:"total_removing_bal" toml:"total_removing_bal" yaml:"total_removing_bal"`
	AvgOpenToBuy           float32 `boil:"avg_open_to_buy" json:"avg_open_to_buy" toml:"avg_open_to_buy" yaml:"avg_open_to_buy"`
	TotalAmtCHNGQ4Q1       float32 `boil:"total_amt_chng_q4_q1" json:"total_amt_chng_q4_q1" toml:"total_amt_chng_q4_q1" yaml:"total_amt_chng_q4_q1"`
	TotalTransAmt          float32 `boil:"total_trans_amt" json:"total_trans_amt" toml:"total_trans_amt" yaml:"total_trans_amt"`
	TotalTransCT           int     `boil:"total_trans_ct" json:"total_trans_ct" toml:"total_trans_ct" yaml:"total_trans_ct"`
	TotalCTCHNGQ4Q1        float32 `boil:"total_ct_chng_q4_q1" json:"total_ct_chng_q4_q1" toml:"total_ct_chng_q4_q1" yaml:"total_ct_chng_q4_q1"`
	AvgUtilizationRatio    float32 `boil:"avg_utilization_ratio" json:"avg_utilization_ratio" toml:"avg_utilization_ratio" yaml:"avg_utilization_ratio"`
	NaiveBayesClassifier1  float32 `boil:"naive_bayes_classifier_1" json:"naive_bayes_classifier_1" toml:"naive_bayes_classifier_1" yaml:"naive_bayes_classifier_1"`
	NaiveBayesClassifier2  float32 `boil:"naive_bayes_classifier_2" json:"naive_bayes_classifier_2" toml:"naive_bayes_classifier_2" yaml:"naive_bayes_classifier_2"`

	R *clientR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L clientL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ClientColumns = struct {
	ID                     string
	Age                    string
	MaritialID             string
	EducationID            string
	GenderID               string
	CardCategoryID         string
	AttritionFlagID        string
	MonthsOnBook           string
	CreditLimit            string
	TotalRelationshipCount string
	MonthInactivate12Mon   string
	ContactsCount12Mon     string
	TotalRemovingBal       string
	AvgOpenToBuy           string
	TotalAmtCHNGQ4Q1       string
	TotalTransAmt          string
	TotalTransCT           string
	TotalCTCHNGQ4Q1        string
	AvgUtilizationRatio    string
	NaiveBayesClassifier1  string
	NaiveBayesClassifier2  string
}{
	ID:                     "id",
	Age:                    "age",
	MaritialID:             "maritial_id",
	EducationID:            "education_id",
	GenderID:               "gender_id",
	CardCategoryID:         "card_category_id",
	AttritionFlagID:        "attrition_flag_id",
	MonthsOnBook:           "months_on_book",
	CreditLimit:            "credit_limit",
	TotalRelationshipCount: "total_relationship_count",
	MonthInactivate12Mon:   "month_inactivate_12_mon",
	ContactsCount12Mon:     "contacts_count_12_mon",
	TotalRemovingBal:       "total_removing_bal",
	AvgOpenToBuy:           "avg_open_to_buy",
	TotalAmtCHNGQ4Q1:       "total_amt_chng_q4_q1",
	TotalTransAmt:          "total_trans_amt",
	TotalTransCT:           "total_trans_ct",
	TotalCTCHNGQ4Q1:        "total_ct_chng_q4_q1",
	AvgUtilizationRatio:    "avg_utilization_ratio",
	NaiveBayesClassifier1:  "naive_bayes_classifier_1",
	NaiveBayesClassifier2:  "naive_bayes_classifier_2",
}

var ClientTableColumns = struct {
	ID                     string
	Age                    string
	MaritialID             string
	EducationID            string
	GenderID               string
	CardCategoryID         string
	AttritionFlagID        string
	MonthsOnBook           string
	CreditLimit            string
	TotalRelationshipCount string
	MonthInactivate12Mon   string
	ContactsCount12Mon     string
	TotalRemovingBal       string
	AvgOpenToBuy           string
	TotalAmtCHNGQ4Q1       string
	TotalTransAmt          string
	TotalTransCT           string
	TotalCTCHNGQ4Q1        string
	AvgUtilizationRatio    string
	NaiveBayesClassifier1  string
	NaiveBayesClassifier2  string
}{
	ID:                     "clients.id",
	Age:                    "clients.age",
	MaritialID:             "clients.maritial_id",
	EducationID:            "clients.education_id",
	GenderID:               "clients.gender_id",
	CardCategoryID:         "clients.card_category_id",
	AttritionFlagID:        "clients.attrition_flag_id",
	MonthsOnBook:           "clients.months_on_book",
	CreditLimit:            "clients.credit_limit",
	TotalRelationshipCount: "clients.total_relationship_count",
	MonthInactivate12Mon:   "clients.month_inactivate_12_mon",
	ContactsCount12Mon:     "clients.contacts_count_12_mon",
	TotalRemovingBal:       "clients.total_removing_bal",
	AvgOpenToBuy:           "clients.avg_open_to_buy",
	TotalAmtCHNGQ4Q1:       "clients.total_amt_chng_q4_q1",
	TotalTransAmt:          "clients.total_trans_amt",
	TotalTransCT:           "clients.total_trans_ct",
	TotalCTCHNGQ4Q1:        "clients.total_ct_chng_q4_q1",
	AvgUtilizationRatio:    "clients.avg_utilization_ratio",
	NaiveBayesClassifier1:  "clients.naive_bayes_classifier_1",
	NaiveBayesClassifier2:  "clients.naive_bayes_classifier_2",
}

// Generated where

type whereHelperfloat32 struct{ field string }

func (w whereHelperfloat32) EQ(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperfloat32) NEQ(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperfloat32) LT(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperfloat32) LTE(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperfloat32) GT(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperfloat32) GTE(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperfloat32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperfloat32) NIN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var ClientWhere = struct {
	ID                     whereHelperint
	Age                    whereHelperint
	MaritialID             whereHelperint
	EducationID            whereHelperint
	GenderID               whereHelperint
	CardCategoryID         whereHelperint
	AttritionFlagID        whereHelperint
	MonthsOnBook           whereHelperint
	CreditLimit            whereHelperfloat32
	TotalRelationshipCount whereHelperint
	MonthInactivate12Mon   whereHelperint
	ContactsCount12Mon     whereHelperint
	TotalRemovingBal       whereHelperint
	AvgOpenToBuy           whereHelperfloat32
	TotalAmtCHNGQ4Q1       whereHelperfloat32
	TotalTransAmt          whereHelperfloat32
	TotalTransCT           whereHelperint
	TotalCTCHNGQ4Q1        whereHelperfloat32
	AvgUtilizationRatio    whereHelperfloat32
	NaiveBayesClassifier1  whereHelperfloat32
	NaiveBayesClassifier2  whereHelperfloat32
}{
	ID:                     whereHelperint{field: "\"clients\".\"id\""},
	Age:                    whereHelperint{field: "\"clients\".\"age\""},
	MaritialID:             whereHelperint{field: "\"clients\".\"maritial_id\""},
	EducationID:            whereHelperint{field: "\"clients\".\"education_id\""},
	GenderID:               whereHelperint{field: "\"clients\".\"gender_id\""},
	CardCategoryID:         whereHelperint{field: "\"clients\".\"card_category_id\""},
	AttritionFlagID:        whereHelperint{field: "\"clients\".\"attrition_flag_id\""},
	MonthsOnBook:           whereHelperint{field: "\"clients\".\"months_on_book\""},
	CreditLimit:            whereHelperfloat32{field: "\"clients\".\"credit_limit\""},
	TotalRelationshipCount: whereHelperint{field: "\"clients\".\"total_relationship_count\""},
	MonthInactivate12Mon:   whereHelperint{field: "\"clients\".\"month_inactivate_12_mon\""},
	ContactsCount12Mon:     whereHelperint{field: "\"clients\".\"contacts_count_12_mon\""},
	TotalRemovingBal:       whereHelperint{field: "\"clients\".\"total_removing_bal\""},
	AvgOpenToBuy:           whereHelperfloat32{field: "\"clients\".\"avg_open_to_buy\""},
	TotalAmtCHNGQ4Q1:       whereHelperfloat32{field: "\"clients\".\"total_amt_chng_q4_q1\""},
	TotalTransAmt:          whereHelperfloat32{field: "\"clients\".\"total_trans_amt\""},
	TotalTransCT:           whereHelperint{field: "\"clients\".\"total_trans_ct\""},
	TotalCTCHNGQ4Q1:        whereHelperfloat32{field: "\"clients\".\"total_ct_chng_q4_q1\""},
	AvgUtilizationRatio:    whereHelperfloat32{field: "\"clients\".\"avg_utilization_ratio\""},
	NaiveBayesClassifier1:  whereHelperfloat32{field: "\"clients\".\"naive_bayes_classifier_1\""},
	NaiveBayesClassifier2:  whereHelperfloat32{field: "\"clients\".\"naive_bayes_classifier_2\""},
}

// ClientRels is where relationship names are stored.
var ClientRels = struct {
	AttritionFlag string
	CardCategory  string
	Education     string
	Gender        string
	Maritial      string
}{
	AttritionFlag: "AttritionFlag",
	CardCategory:  "CardCategory",
	Education:     "Education",
	Gender:        "Gender",
	Maritial:      "Maritial",
}

// clientR is where relationships are stored.
type clientR struct {
	AttritionFlag *AttritionFlag `boil:"AttritionFlag" json:"AttritionFlag" toml:"AttritionFlag" yaml:"AttritionFlag"`
	CardCategory  *CardCategory  `boil:"CardCategory" json:"CardCategory" toml:"CardCategory" yaml:"CardCategory"`
	Education     *Education     `boil:"Education" json:"Education" toml:"Education" yaml:"Education"`
	Gender        *Gender        `boil:"Gender" json:"Gender" toml:"Gender" yaml:"Gender"`
	Maritial      *Maritial      `boil:"Maritial" json:"Maritial" toml:"Maritial" yaml:"Maritial"`
}

// NewStruct creates a new relationship struct
func (*clientR) NewStruct() *clientR {
	return &clientR{}
}

// clientL is where Load methods for each relationship are stored.
type clientL struct{}

var (
	clientAllColumns            = []string{"id", "age", "maritial_id", "education_id", "gender_id", "card_category_id", "attrition_flag_id", "months_on_book", "credit_limit", "total_relationship_count", "month_inactivate_12_mon", "contacts_count_12_mon", "total_removing_bal", "avg_open_to_buy", "total_amt_chng_q4_q1", "total_trans_amt", "total_trans_ct", "total_ct_chng_q4_q1", "avg_utilization_ratio", "naive_bayes_classifier_1", "naive_bayes_classifier_2"}
	clientColumnsWithoutDefault = []string{"age", "maritial_id", "education_id", "gender_id", "card_category_id", "attrition_flag_id", "months_on_book", "credit_limit", "total_relationship_count", "month_inactivate_12_mon", "contacts_count_12_mon", "total_removing_bal", "avg_open_to_buy", "total_amt_chng_q4_q1", "total_trans_amt", "total_trans_ct", "total_ct_chng_q4_q1", "avg_utilization_ratio", "naive_bayes_classifier_1", "naive_bayes_classifier_2"}
	clientColumnsWithDefault    = []string{"id"}
	clientPrimaryKeyColumns     = []string{"id"}
)

type (
	// ClientSlice is an alias for a slice of pointers to Client.
	// This should almost always be used instead of []Client.
	ClientSlice []*Client
	// ClientHook is the signature for custom Client hook methods
	ClientHook func(context.Context, boil.ContextExecutor, *Client) error

	clientQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	clientType                 = reflect.TypeOf(&Client{})
	clientMapping              = queries.MakeStructMapping(clientType)
	clientPrimaryKeyMapping, _ = queries.BindMapping(clientType, clientMapping, clientPrimaryKeyColumns)
	clientInsertCacheMut       sync.RWMutex
	clientInsertCache          = make(map[string]insertCache)
	clientUpdateCacheMut       sync.RWMutex
	clientUpdateCache          = make(map[string]updateCache)
	clientUpsertCacheMut       sync.RWMutex
	clientUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var clientBeforeInsertHooks []ClientHook
var clientBeforeUpdateHooks []ClientHook
var clientBeforeDeleteHooks []ClientHook
var clientBeforeUpsertHooks []ClientHook

var clientAfterInsertHooks []ClientHook
var clientAfterSelectHooks []ClientHook
var clientAfterUpdateHooks []ClientHook
var clientAfterDeleteHooks []ClientHook
var clientAfterUpsertHooks []ClientHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Client) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Client) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Client) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Client) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Client) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Client) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Client) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Client) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Client) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clientAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddClientHook registers your hook function for all future operations.
func AddClientHook(hookPoint boil.HookPoint, clientHook ClientHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		clientBeforeInsertHooks = append(clientBeforeInsertHooks, clientHook)
	case boil.BeforeUpdateHook:
		clientBeforeUpdateHooks = append(clientBeforeUpdateHooks, clientHook)
	case boil.BeforeDeleteHook:
		clientBeforeDeleteHooks = append(clientBeforeDeleteHooks, clientHook)
	case boil.BeforeUpsertHook:
		clientBeforeUpsertHooks = append(clientBeforeUpsertHooks, clientHook)
	case boil.AfterInsertHook:
		clientAfterInsertHooks = append(clientAfterInsertHooks, clientHook)
	case boil.AfterSelectHook:
		clientAfterSelectHooks = append(clientAfterSelectHooks, clientHook)
	case boil.AfterUpdateHook:
		clientAfterUpdateHooks = append(clientAfterUpdateHooks, clientHook)
	case boil.AfterDeleteHook:
		clientAfterDeleteHooks = append(clientAfterDeleteHooks, clientHook)
	case boil.AfterUpsertHook:
		clientAfterUpsertHooks = append(clientAfterUpsertHooks, clientHook)
	}
}

// One returns a single client record from the query.
func (q clientQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Client, error) {
	o := &Client{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for clients")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Client records from the query.
func (q clientQuery) All(ctx context.Context, exec boil.ContextExecutor) (ClientSlice, error) {
	var o []*Client

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Client slice")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Client records in the query.
func (q clientQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count clients rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q clientQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if clients exists")
	}

	return count > 0, nil
}

// AttritionFlag pointed to by the foreign key.
func (o *Client) AttritionFlag(mods ...qm.QueryMod) attritionFlagQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AttritionFlagID),
	}

	queryMods = append(queryMods, mods...)

	query := AttritionFlags(queryMods...)
	queries.SetFrom(query.Query, "\"attrition_flags\"")

	return query
}

// CardCategory pointed to by the foreign key.
func (o *Client) CardCategory(mods ...qm.QueryMod) cardCategoryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CardCategoryID),
	}

	queryMods = append(queryMods, mods...)

	query := CardCategories(queryMods...)
	queries.SetFrom(query.Query, "\"card_categories\"")

	return query
}

// Education pointed to by the foreign key.
func (o *Client) Education(mods ...qm.QueryMod) educationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.EducationID),
	}

	queryMods = append(queryMods, mods...)

	query := Educations(queryMods...)
	queries.SetFrom(query.Query, "\"educations\"")

	return query
}

// Gender pointed to by the foreign key.
func (o *Client) Gender(mods ...qm.QueryMod) genderQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.GenderID),
	}

	queryMods = append(queryMods, mods...)

	query := Genders(queryMods...)
	queries.SetFrom(query.Query, "\"genders\"")

	return query
}

// Maritial pointed to by the foreign key.
func (o *Client) Maritial(mods ...qm.QueryMod) maritialQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MaritialID),
	}

	queryMods = append(queryMods, mods...)

	query := Maritials(queryMods...)
	queries.SetFrom(query.Query, "\"maritials\"")

	return query
}

// LoadAttritionFlag allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (clientL) LoadAttritionFlag(ctx context.Context, e boil.ContextExecutor, singular bool, maybeClient interface{}, mods queries.Applicator) error {
	var slice []*Client
	var object *Client

	if singular {
		object = maybeClient.(*Client)
	} else {
		slice = *maybeClient.(*[]*Client)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &clientR{}
		}
		args = append(args, object.AttritionFlagID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clientR{}
			}

			for _, a := range args {
				if a == obj.AttritionFlagID {
					continue Outer
				}
			}

			args = append(args, obj.AttritionFlagID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`attrition_flags`),
		qm.WhereIn(`attrition_flags.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AttritionFlag")
	}

	var resultSlice []*AttritionFlag
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AttritionFlag")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for attrition_flags")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for attrition_flags")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AttritionFlag = foreign
		if foreign.R == nil {
			foreign.R = &attritionFlagR{}
		}
		foreign.R.Clients = append(foreign.R.Clients, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AttritionFlagID == foreign.ID {
				local.R.AttritionFlag = foreign
				if foreign.R == nil {
					foreign.R = &attritionFlagR{}
				}
				foreign.R.Clients = append(foreign.R.Clients, local)
				break
			}
		}
	}

	return nil
}

// LoadCardCategory allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (clientL) LoadCardCategory(ctx context.Context, e boil.ContextExecutor, singular bool, maybeClient interface{}, mods queries.Applicator) error {
	var slice []*Client
	var object *Client

	if singular {
		object = maybeClient.(*Client)
	} else {
		slice = *maybeClient.(*[]*Client)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &clientR{}
		}
		args = append(args, object.CardCategoryID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clientR{}
			}

			for _, a := range args {
				if a == obj.CardCategoryID {
					continue Outer
				}
			}

			args = append(args, obj.CardCategoryID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`card_categories`),
		qm.WhereIn(`card_categories.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CardCategory")
	}

	var resultSlice []*CardCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CardCategory")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for card_categories")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for card_categories")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CardCategory = foreign
		if foreign.R == nil {
			foreign.R = &cardCategoryR{}
		}
		foreign.R.Clients = append(foreign.R.Clients, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CardCategoryID == foreign.ID {
				local.R.CardCategory = foreign
				if foreign.R == nil {
					foreign.R = &cardCategoryR{}
				}
				foreign.R.Clients = append(foreign.R.Clients, local)
				break
			}
		}
	}

	return nil
}

// LoadEducation allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (clientL) LoadEducation(ctx context.Context, e boil.ContextExecutor, singular bool, maybeClient interface{}, mods queries.Applicator) error {
	var slice []*Client
	var object *Client

	if singular {
		object = maybeClient.(*Client)
	} else {
		slice = *maybeClient.(*[]*Client)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &clientR{}
		}
		args = append(args, object.EducationID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clientR{}
			}

			for _, a := range args {
				if a == obj.EducationID {
					continue Outer
				}
			}

			args = append(args, obj.EducationID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`educations`),
		qm.WhereIn(`educations.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Education")
	}

	var resultSlice []*Education
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Education")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for educations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for educations")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Education = foreign
		if foreign.R == nil {
			foreign.R = &educationR{}
		}
		foreign.R.Clients = append(foreign.R.Clients, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.EducationID == foreign.ID {
				local.R.Education = foreign
				if foreign.R == nil {
					foreign.R = &educationR{}
				}
				foreign.R.Clients = append(foreign.R.Clients, local)
				break
			}
		}
	}

	return nil
}

// LoadGender allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (clientL) LoadGender(ctx context.Context, e boil.ContextExecutor, singular bool, maybeClient interface{}, mods queries.Applicator) error {
	var slice []*Client
	var object *Client

	if singular {
		object = maybeClient.(*Client)
	} else {
		slice = *maybeClient.(*[]*Client)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &clientR{}
		}
		args = append(args, object.GenderID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clientR{}
			}

			for _, a := range args {
				if a == obj.GenderID {
					continue Outer
				}
			}

			args = append(args, obj.GenderID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`genders`),
		qm.WhereIn(`genders.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Gender")
	}

	var resultSlice []*Gender
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Gender")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for genders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for genders")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Gender = foreign
		if foreign.R == nil {
			foreign.R = &genderR{}
		}
		foreign.R.Clients = append(foreign.R.Clients, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.GenderID == foreign.ID {
				local.R.Gender = foreign
				if foreign.R == nil {
					foreign.R = &genderR{}
				}
				foreign.R.Clients = append(foreign.R.Clients, local)
				break
			}
		}
	}

	return nil
}

// LoadMaritial allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (clientL) LoadMaritial(ctx context.Context, e boil.ContextExecutor, singular bool, maybeClient interface{}, mods queries.Applicator) error {
	var slice []*Client
	var object *Client

	if singular {
		object = maybeClient.(*Client)
	} else {
		slice = *maybeClient.(*[]*Client)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &clientR{}
		}
		args = append(args, object.MaritialID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clientR{}
			}

			for _, a := range args {
				if a == obj.MaritialID {
					continue Outer
				}
			}

			args = append(args, obj.MaritialID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`maritials`),
		qm.WhereIn(`maritials.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Maritial")
	}

	var resultSlice []*Maritial
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Maritial")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for maritials")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for maritials")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Maritial = foreign
		if foreign.R == nil {
			foreign.R = &maritialR{}
		}
		foreign.R.Clients = append(foreign.R.Clients, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.MaritialID == foreign.ID {
				local.R.Maritial = foreign
				if foreign.R == nil {
					foreign.R = &maritialR{}
				}
				foreign.R.Clients = append(foreign.R.Clients, local)
				break
			}
		}
	}

	return nil
}

// SetAttritionFlag of the client to the related item.
// Sets o.R.AttritionFlag to related.
// Adds o to related.R.Clients.
func (o *Client) SetAttritionFlag(ctx context.Context, exec boil.ContextExecutor, insert bool, related *AttritionFlag) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"clients\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"attrition_flag_id"}),
		strmangle.WhereClause("\"", "\"", 2, clientPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AttritionFlagID = related.ID
	if o.R == nil {
		o.R = &clientR{
			AttritionFlag: related,
		}
	} else {
		o.R.AttritionFlag = related
	}

	if related.R == nil {
		related.R = &attritionFlagR{
			Clients: ClientSlice{o},
		}
	} else {
		related.R.Clients = append(related.R.Clients, o)
	}

	return nil
}

// SetCardCategory of the client to the related item.
// Sets o.R.CardCategory to related.
// Adds o to related.R.Clients.
func (o *Client) SetCardCategory(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CardCategory) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"clients\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"card_category_id"}),
		strmangle.WhereClause("\"", "\"", 2, clientPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CardCategoryID = related.ID
	if o.R == nil {
		o.R = &clientR{
			CardCategory: related,
		}
	} else {
		o.R.CardCategory = related
	}

	if related.R == nil {
		related.R = &cardCategoryR{
			Clients: ClientSlice{o},
		}
	} else {
		related.R.Clients = append(related.R.Clients, o)
	}

	return nil
}

// SetEducation of the client to the related item.
// Sets o.R.Education to related.
// Adds o to related.R.Clients.
func (o *Client) SetEducation(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Education) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"clients\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"education_id"}),
		strmangle.WhereClause("\"", "\"", 2, clientPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.EducationID = related.ID
	if o.R == nil {
		o.R = &clientR{
			Education: related,
		}
	} else {
		o.R.Education = related
	}

	if related.R == nil {
		related.R = &educationR{
			Clients: ClientSlice{o},
		}
	} else {
		related.R.Clients = append(related.R.Clients, o)
	}

	return nil
}

// SetGender of the client to the related item.
// Sets o.R.Gender to related.
// Adds o to related.R.Clients.
func (o *Client) SetGender(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Gender) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"clients\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"gender_id"}),
		strmangle.WhereClause("\"", "\"", 2, clientPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.GenderID = related.ID
	if o.R == nil {
		o.R = &clientR{
			Gender: related,
		}
	} else {
		o.R.Gender = related
	}

	if related.R == nil {
		related.R = &genderR{
			Clients: ClientSlice{o},
		}
	} else {
		related.R.Clients = append(related.R.Clients, o)
	}

	return nil
}

// SetMaritial of the client to the related item.
// Sets o.R.Maritial to related.
// Adds o to related.R.Clients.
func (o *Client) SetMaritial(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Maritial) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"clients\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"maritial_id"}),
		strmangle.WhereClause("\"", "\"", 2, clientPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.MaritialID = related.ID
	if o.R == nil {
		o.R = &clientR{
			Maritial: related,
		}
	} else {
		o.R.Maritial = related
	}

	if related.R == nil {
		related.R = &maritialR{
			Clients: ClientSlice{o},
		}
	} else {
		related.R.Clients = append(related.R.Clients, o)
	}

	return nil
}

// Clients retrieves all the records using an executor.
func Clients(mods ...qm.QueryMod) clientQuery {
	mods = append(mods, qm.From("\"clients\""))
	return clientQuery{NewQuery(mods...)}
}

// FindClient retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindClient(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Client, error) {
	clientObj := &Client{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"clients\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, clientObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from clients")
	}

	if err = clientObj.doAfterSelectHooks(ctx, exec); err != nil {
		return clientObj, err
	}

	return clientObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Client) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no clients provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clientColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	clientInsertCacheMut.RLock()
	cache, cached := clientInsertCache[key]
	clientInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			clientAllColumns,
			clientColumnsWithDefault,
			clientColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(clientType, clientMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(clientType, clientMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"clients\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"clients\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into clients")
	}

	if !cached {
		clientInsertCacheMut.Lock()
		clientInsertCache[key] = cache
		clientInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Client.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Client) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	clientUpdateCacheMut.RLock()
	cache, cached := clientUpdateCache[key]
	clientUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			clientAllColumns,
			clientPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update clients, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"clients\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, clientPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(clientType, clientMapping, append(wl, clientPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update clients row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for clients")
	}

	if !cached {
		clientUpdateCacheMut.Lock()
		clientUpdateCache[key] = cache
		clientUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q clientQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for clients")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for clients")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ClientSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"clients\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, clientPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in client slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all client")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Client) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no clients provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clientColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	clientUpsertCacheMut.RLock()
	cache, cached := clientUpsertCache[key]
	clientUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			clientAllColumns,
			clientColumnsWithDefault,
			clientColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			clientAllColumns,
			clientPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert clients, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(clientPrimaryKeyColumns))
			copy(conflict, clientPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"clients\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(clientType, clientMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(clientType, clientMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert clients")
	}

	if !cached {
		clientUpsertCacheMut.Lock()
		clientUpsertCache[key] = cache
		clientUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Client record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Client) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Client provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), clientPrimaryKeyMapping)
	sql := "DELETE FROM \"clients\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from clients")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for clients")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q clientQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no clientQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from clients")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for clients")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ClientSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(clientBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"clients\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, clientPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from client slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for clients")
	}

	if len(clientAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Client) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindClient(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ClientSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ClientSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"clients\".* FROM \"clients\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, clientPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ClientSlice")
	}

	*o = slice

	return nil
}

// ClientExists checks if the Client row exists.
func ClientExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"clients\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if clients exists")
	}

	return exists, nil
}
